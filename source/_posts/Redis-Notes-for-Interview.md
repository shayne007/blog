---
title: Redis Notes for Interview
author: Charlie
date: 2025-06-01 16:20:52
tags: [redis]
categories: [redis]
---

* Redis基础知识
* 关键词
   * 内存数据库
   * 数据结构：string、hash、set、sorted set、list、geo、hyperloglog
   * 集群模式：主从、哨兵、cluster分片
   * 使用缓存进行性能优化
* 为什么使用redis？
   * **性能**：我们在碰到需要执行耗时特别久，且结果不频繁变动的SQL，就特别适合将运行结果放入缓存。这样， 后面的请求就去缓存中读取，使得请求能够迅速响应。
   * **并发**：在大并发的情况下，所有的请求直接访问数据库，数据库会出现连接异常。这个时候，就需要使用redis 做一个缓冲操作，让请求先访问到redis，而不是直接访问数据库（**MySQl支持1500QPS，而Redis支持2-5wQPS**）。
* redis的使用场景
   * 缓存
   * 秒杀
   * 分布式锁
* Redis为什么使用单线程
* 关键词
   * 线程任务：命令处理、io处理、持久化、数据同步
   * 6.0版本、配置开启多线程
   * epoll、reactor
* 高性能的原因
   * 内存操作
   * 在Linux上采用了epoll和reactor结合的IO模型
      * epoll的本质是管理一堆socket文件描述符
         * **红黑树**结构维护的全部监控文件描述符
         * **双向链表**维护的就绪列表
         * 中断机制添加就绪文件描述符
         * 关键api：**epoll_create、epoll_ctl、epoll_wait**
         * poll和select的区别：
      * reactor模式
         * Reactor（Dispatcher）调用epoll拿到可用文件描述符，分发事件
         * Acceptor处理创建连接事件
         * Handler处理IO读写事件，
* Redis数据类型的底层数据结构
* 关键词
   * skiplist
* String（字符串）
   * SDS（简单动态字符串）
   * 缓存用户信息、计数器、分布式锁（setnx）
* Hash（哈希表）
   * ziplist（小数据） + hashtable（大数据）
   * 存储对象
* List（列表）
   * 双向链表或ziplist
   * 消息队列、最新文章列表
* Set（集合）
   * intset（整数集合）或hashtable
   * 标签系统、共同好友（sinter求交集）
* ZSet（有序集合）
   * ziplist + skiplist（跳表）
   * 排行榜（ZADD/ZRANGE）、延时队列
* Redis怎么做数据持久化
* 关键词
   * AOF、RDB、混合模式
* RDB
   * 定时生成内存数据的二进制快照文件
   * fork子进程
   * 每个5分钟甚至更长时间执行一次bgsave，数据丢失问题
* AOF
   * 记录所有写操作命令
   * 同步磁盘策略
      * 每秒同步（appendfsync everysec）
      * 每次修改同步（appendfsync always）
      * 不同步（appendfsync no）
   * rewrite机制
* 二者比较
   * RDB是每隔一段时间持久化一次, 故障时就会丢失宕机时刻与上一次持久化之间的数据，无法保证数据完整性
   * AOF存储的是指令序列, 恢复重放时要花费很长时间并且文件更大
* Redis有哪些集群部署模式
* 关键词
   * 一主多从，读写分离
   * 哨兵
   * Cluster分片模式
* 一主多从
   * 读操作，主库从库都可以接受
   * 写操作，首先到主库执行，然后主库将写操作同步给从库
* 哨兵
   * 主库挂了，数据不能写入，通过哨兵重新选主
   * 监控、选主、通知
      * 哨兵集群
      * 主观下线
      * 客观下线，判断主库下线，需要大多数的哨兵都标记下线
      * 选主打分规则
         * 从库优先级配置
         * 从库复制进度
         * 从库ID号小的
      * 多个哨兵实例发布订阅连接信息，以此进行信息交换，组成哨兵集群
      * 基于info命令的从库列表，帮助哨兵与从库建立连接
      * 客户端从哨兵订阅关键事件
         * 主库下线判断
         * 新主库选定
         * 从库重新配置
   * 哨兵之间也有leader选举，决定由谁进行主从切换
* cluster分片
   * RDB持久化，fork子进程阻塞主线程，当数据量大时导致Redis响应变慢
   * 数据量大时使用分片集群解决单实例的问题
      * 超过25G
   * CPU密集型任务可以通过分片集群利用多核CPU
   * 采用hash槽来处理数据与实例之间的映射关系
      * 固定16384个槽位
      * 哈希槽与实例的关系可以灵活分配
      * 手动分配需要将16384个槽位分配完
* 缓存模式与缓存一致性
* 关键词
   * Cache Aside旁路缓存
   * Read Through、Write Through、Write Back、Single Flight
   * 删除缓存、延迟双删
*  如何保证缓存与数据库的一致性？
   * Cache-Aside 模式：
      * 读：缓存命中则返回，否则查数据库并回填缓存。
      * 写：先更新数据库，再删除缓存。
   * 延迟双删
      * 更新数据库后直接删除缓存，过一段时间紧后，再次删除缓存
      * 降低了缓存命中率
   * 兜底方案：设置缓存过期时间、使用消息队列异步同步。

* 穿透、击穿、雪崩缓存问题
* 关键词
   * 热点数据、随机过期时间
   * 布隆过滤器
* 缓存雪崩
   * 大量同时过期的key
   * redis实例宕机
   * 应对策略
      * 随机过期时间、服务降级
      * 熔断限流、高可靠集群部署；
* 缓存穿透
   * 数据既不在redis中，也不在数据库（数据误删或恶意攻击）。
   * 应对策略：
      * 缓存空值或缺省值
      * 布隆过滤器
         * 数据结构：位数组 + 多个哈希函数。
         * 写入：对元素进行多次哈希，将对应位设为 1。
         * 查询：若所有哈希位均为 1，则元素可能存在（可能存在误判）。
      * 前端进行非法参数校验。
* 缓存击穿
   * 单个热点数据过期失效。
   * 应对策略：
      * 热点数据不设置过期时间；
* 怎么使用Redis实现分布式锁
* 关键词
   * 支持排他性操作的中间件都可以实现分布式锁
   * setNX同一个key只会有一个执行成功
   * 过期时间
   * 超时时间
   * 锁续期
* 加锁失败后重试
   * 确定等待时间：业务正常执行完毕的时间（99线或999线）
   * 实现等待：
      * sleep；
      * 监听锁的释放（del事件）
   * lua脚本实现超时重试
* 加锁成功了为什么需要设置过期时间
   * 加锁成功的线程，执行业务的过程中崩溃，锁未释放
   * 过期时间应该根据业务设置，99%的业务拿到锁之后，1s内完成，可以设置过期时间为2秒，或者保险起见，设置10秒设置1分钟都行。
   * 如果业务持有锁在过期时间内执行不完，需要续期
      * 过期之前重置下过期时间
      * 启动守护线程定时检查当前线程是否持有锁，持有则重置过期时间
      * redission看门狗机制
* 释放锁
   * 持有锁的机器宕机后恢复
   * 释放需要检查这个锁是否是自己的，防止释放掉其他线程持有的锁
* Redlock
* SingleFlight模式优化分布式锁


